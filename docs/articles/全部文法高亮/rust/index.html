<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/bnf.css /><link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/css.css /><link rel='stylesheet' href=../../../css/dot.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/lua.css /><link rel='stylesheet' href=../../../css/python.css /><link rel='stylesheet' href=../../../css/riscvasm.css /><link rel='stylesheet' href=../../../css/rust.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/toml.css /><link rel='stylesheet' href=../../../css/txt.css /><link rel='stylesheet' href=../../../css/verilog.css /><link rel='stylesheet' href=../../../css/x86asm.css /><link rel='stylesheet' href=../../../css/xml.css /><link rel='stylesheet' href=../../../css/yaml.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/syntaxlight.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">rust</a><ul><li><a href="#h2-1">1.rs</a></li></ul><ul><li><a href="#h2-2">2.rs</a></li></ul><ul><li><a href="#h2-3">3.rs</a></li></ul><ul><li><a href="#h2-4">4.rs</a></li></ul><ul><li><a href="#h2-5">5.rs</a></li></ul><ul><li><a href="#h2-6">6.rs</a></li></ul><ul><li><a href="#h2-7">7.rs</a></li></ul><ul><li><a href="#h2-8">8.rs</a></li></ul><ul><li><a href="#h2-9">9.rs</a></li></ul><ul><li><a href="#h2-10">10.rs</a></li></ul><ul><li><a href="#h2-11">11.rs</a></li></ul><ul><li><a href="#h2-12">12.rs</a></li></ul><ul><li><a href="#h2-13">13.rs</a></li></ul><ul><li><a href="#h2-14">14.rs</a></li></ul><ul><li><a href="#h2-15">15.rs</a></li></ul><ul><li><a href="#h2-16">16.rs</a></li></ul><ul><li><a href="#h2-17">17.rs</a></li></ul><ul><li><a href="#h2-18">18.rs</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">rust</h1><h2 id="h2-1"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/1.rs" target="_blank">1.rs</a></h2><pre class="language-rust"><code><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token Identifier ImportLibName PathGlob ID">rand</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">Rng</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">cmp</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">Ordering</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">io</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">alloc</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token PathGlob PathGlob BraceDepth-0 LCURLY_BRACE">{</span><span class="Token PathGlob DEREF">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword PathGlob SELF">self</span><span class="Token PathGlob PathGlob BraceDepth-0 RCURLY_BRACE">}</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Hello, world!&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">secret_number</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">rand</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier ExprPathSegment FunctionCall ID">thread_rng</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">gen_range</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token Punctuator Expr CONCAT">..</span><span class="Token Number PrimaryGroup NUMBER">100</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;secret number = </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">secret_number</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;guess a number&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LoopExpr LOOP">loop</span><span class="Token Keyword LoopExpr SPACE"> </span><span class="Token BlockExpr LoopExpr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr LoopExpr LF">
</span><span class="Token BlockExpr LoopExpr SPACE">        </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Keyword Pat MUT">mut</span><span class="Token Keyword Pat SPACE"> </span><span class="Token Identifier Pat MutableVar ID">guess</span><span class="Token Identifier Pat SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token ImportLibName Identifier ExprPathSegment ID">String</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier ExprPathSegment FunctionCall ID">new</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">        </span><span class="Token ImportLibName Identifier ExprPathSegment ID">io</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier ExprPathSegment FunctionCall ID">stdin</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">read_line</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token UnaryGroup Expr AMPERSAND">&amp;</span><span class="Token Keyword UnaryGroup MUT">mut</span><span class="Token Keyword UnaryGroup SPACE"> </span><span class="Token MutableVar Identifier ExprPathSegment ID">guess</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">expect</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;error!&quot;</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">        </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">guess</span><span class="Token LetExpr COLON">:</span><span class="Token LetExpr SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">u32</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Keyword MatchExpr MATCH">match</span><span class="Token Keyword MatchExpr SPACE"> </span><span class="Token MutableVar Identifier ExprPathSegment ID">guess</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">trim</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">parse</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup SPACE"> </span><span class="Token MatchExpr PrimaryGroup BraceDepth-2 LCURLY_BRACE">{</span><span class="Token MatchExpr PrimaryGroup LF">
</span><span class="Token MatchExpr PrimaryGroup SPACE">            </span><span class="Token Identifier Path ID">Ok</span><span class="Token Pat BraceDepth-0 LPAREN">(</span><span class="Token Identifier Path ID">num</span><span class="Token Pat BraceDepth-0 RPAREN">)</span><span class="Token Pat SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier ExprPathSegment ID">num</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">            </span><span class="Token Identifier Path ID">Err</span><span class="Token Pat BraceDepth-0 LPAREN">(</span><span class="Token Identifier Path ID">_</span><span class="Token Pat BraceDepth-0 RPAREN">)</span><span class="Token Pat SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Keyword PrimaryGroup CONTINUE">continue</span><span class="Token Keyword PrimaryGroup LF">
</span><span class="Token Keyword PrimaryGroup SPACE">        </span><span class="Token MatchExpr PrimaryGroup BraceDepth-2 RCURLY_BRACE">}</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">        </span><span class="Token LetExpr COMMENT">// println!(&quot;what you guess in {}&quot;, guess);</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">        </span><span class="Token Keyword MatchExpr MATCH">match</span><span class="Token Keyword MatchExpr SPACE"> </span><span class="Token MutableVar Identifier ExprPathSegment ID">guess</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">cmp</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token UnaryGroup Expr AMPERSAND">&amp;</span><span class="Token Identifier ExprPathSegment ID">secret_number</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup SPACE"> </span><span class="Token MatchExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">            </span><span class="Token ImportLibName Identifier Path ID">Ordering</span><span class="Token Path Pat DOUBLE_COLON">::</span><span class="Token Identifier ID">Less</span><span class="Token Identifier SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-0 LPAREN">(</span><span class="Token String STRING">&quot;too small&quot;</span><span class="Token MacroExpr Expr BraceDepth-0 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">            </span><span class="Token ImportLibName Identifier Path ID">Ordering</span><span class="Token Path Pat DOUBLE_COLON">::</span><span class="Token Identifier ID">Greater</span><span class="Token Identifier SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-0 LPAREN">(</span><span class="Token String STRING">&quot;too big&quot;</span><span class="Token MacroExpr Expr BraceDepth-0 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">            </span><span class="Token ImportLibName Identifier Path ID">Ordering</span><span class="Token Path Pat DOUBLE_COLON">::</span><span class="Token Identifier ID">Equal</span><span class="Token Identifier SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token BlockExpr MatchItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr MatchItem LF">
</span><span class="Token BlockExpr MatchItem SPACE">                </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;you win!&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">                </span><span class="Token Keyword PrimaryGroup BREAK">break</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">            </span><span class="Token BlockExpr MatchItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token MatchExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">    </span><span class="Token BlockExpr LoopExpr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr LoopExpr LF">
</span><span class="Token BlockExpr LoopExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Keyword Pat MUT">mut</span><span class="Token Keyword Pat SPACE"> </span><span class="Token Identifier Pat MutableVar ID">counter</span><span class="Token Identifier Pat SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">result</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Keyword LoopExpr LOOP">loop</span><span class="Token Keyword LoopExpr SPACE"> </span><span class="Token BlockExpr LoopExpr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr LoopExpr LF">
</span><span class="Token BlockExpr LoopExpr SPACE">        </span><span class="Token MutableVar Identifier ExprPathSegment ID">counter</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ADD_ASSIGN">+=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">        </span><span class="Token Keyword IfExpr IF">if</span><span class="Token Keyword IfExpr SPACE"> </span><span class="Token MutableVar Identifier ExprPathSegment ID">counter</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr EQ">==</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">10</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token BlockExpr IfExpr LF">
</span><span class="Token BlockExpr IfExpr SPACE">            </span><span class="Token Keyword PrimaryGroup BREAK">break</span><span class="Token Keyword PrimaryGroup SPACE"> </span><span class="Token MutableVar Identifier ExprPathSegment ID">counter</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr MUL">*</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">        </span><span class="Token BlockExpr IfExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token BlockExpr IfExpr LF">
</span><span class="Token BlockExpr IfExpr SPACE">    </span><span class="Token BlockExpr LoopExpr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// println!(&quot;result = {}&quot;, result);</span><span class="Token LetExpr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token BlockExpr FnItem LF">
</span></code></pre><h2 id="h2-2"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/2.rs" target="_blank">2.rs</a></h2><pre class="language-rust"><code><span class="Token COMMENT">// test use path_glob</span><span class="Token LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token Identifier ImportLibName PathGlob ID">rand</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">Rng</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">cmp</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">Ordering</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">io</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">alloc</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token PathGlob PathGlob BraceDepth-0 LCURLY_BRACE">{</span><span class="Token PathGlob DEREF">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword PathGlob SELF">self</span><span class="Token PathGlob PathGlob BraceDepth-0 RCURLY_BRACE">}</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">alloc</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token PathGlob PathGlob BraceDepth-0 LCURLY_BRACE">{</span><span class="Token PathGlob DEREF">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token PathGlob BraceDepth-1 LCURLY_BRACE">{</span><span class="Token Keyword PathGlob SELF">self</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token PathGlob DEREF">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token PathGlob BraceDepth-2 LCURLY_BRACE">{</span><span class="Token PathGlob BraceDepth-0 LCURLY_BRACE">{</span><span class="Token PathGlob DEREF">*</span><span class="Token PathGlob BraceDepth-0 RCURLY_BRACE">}</span><span class="Token PathGlob BraceDepth-2 RCURLY_BRACE">}</span><span class="Token PathGlob BraceDepth-1 RCURLY_BRACE">}</span><span class="Token PathGlob PathGlob BraceDepth-0 RCURLY_BRACE">}</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">alloc</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token PathGlob PathGlob BraceDepth-0 LCURLY_BRACE">{</span><span class="Token PathGlob BraceDepth-1 LCURLY_BRACE">{</span><span class="Token Keyword PathGlob SELF">self</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ImportLibName PathGlob ID">GlobalAlloc</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ImportLibName PathGlob ID">Layout</span><span class="Token PathGlob BraceDepth-1 RCURLY_BRACE">}</span><span class="Token PathGlob PathGlob BraceDepth-0 RCURLY_BRACE">}</span><span class="Token UseItem ItemWithAttrs SEMI">;</span></code></pre><h2 id="h2-3"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/3.rs" target="_blank">3.rs</a></h2><pre class="language-rust"><code><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;secret number = </span><span class="Token String STRING">{{</span><span class="Token String STRING">123</span><span class="Token String STRING">}}</span><span class="Token String STRING"> </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">secret_number</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;guess a number&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">format</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;test&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// =&gt; &quot;test&quot;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">format</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;hello </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;world!&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// =&gt; &quot;hello world!&quot;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">format</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;x = </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">, y = </span><span class="Token Format String STRING">{</span><span class="Token String ID">val</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">10</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">val</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">30</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// =&gt; &quot;x = 10, y = 30&quot;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Pat LetExpr BraceDepth-1 LPAREN">(</span><span class="Token Identifier Path ID">x</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier Path ID">y</span><span class="Token Pat LetExpr BraceDepth-1 RPAREN">)</span><span class="Token Pat LetExpr SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2</span><span class="Token PrimaryGroup Expr BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">format</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String ID">x</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> + </span><span class="Token Format String STRING">{</span><span class="Token String ID">y</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> = 3&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// =&gt; &quot;1 + 2 = 3&quot;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Name: </span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">0</span><span class="Token Format String STRING">}</span><span class="Token String STRING">, Age: </span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">1</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">name</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">age</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Value: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:&gt;</span><span class="Token String NUMBER">5</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">value</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Pi: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:.</span><span class="Token String NUMBER">2</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">pi</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Pi: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:&lt;</span><span class="Token String NUMBER">8.2e</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">pi</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Value: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">5</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">value</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Pi: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:&lt;</span><span class="Token String NUMBER">8.2</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">pi</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Value: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:&lt;</span><span class="Token String NUMBER">+5</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">value</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String ID">number:0&gt;width$</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">number</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">width</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Number PrimaryGroup NUMBER">5</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// TODO</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String ID">number:0&lt;5</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">number</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// TODO</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-4"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/4.rs" target="_blank">4.rs</a></h2><pre class="language-rust"><code><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">io</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">io</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">Write</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token Identifier ImportLibName PathGlob ID">serde_json</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">ser</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token PathGlob PathGlob BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Identifier ImportLibName PathGlob ID">Formatter</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ImportLibName PathGlob ID">PrettyFormatter</span><span class="Token PathGlob PathGlob BraceDepth-0 RCURLY_BRACE">}</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword Visibility PUB">pub</span><span class="Token Visibility AttrsAndVis BraceDepth-0 LPAREN">(</span><span class="Token Keyword Visibility CRATE">crate</span><span class="Token Visibility AttrsAndVis BraceDepth-0 RPAREN">)</span><span class="Token Visibility AttrsAndVis SPACE"> </span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">MyFormatter</span><span class="Token Identifier StructItem ClassName SPACE"> </span><span class="Token RecordStructBody StructItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem SPACE">    </span><span class="Token Identifier RecordStructMember ID">pretty_formatter</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">PrettyFormatter</span><span class="Token GenericValues TypePathSegment BraceDepth-1 LANGLE_BRACE">&lt;</span><span class="Token GenericValues TypePathSegment LIFETIME">&#x27;static</span><span class="Token GenericValues TypePathSegment BraceDepth-1 RANGLE_BRACE">&gt;</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token RecordStructBody StructItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token Keyword ImplItem IMPL">impl</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ClassName Identifier TypePathSegment TypeBound ID">MyFormatter</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 LCURLY_BRACE">{</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token Keyword Visibility PUB">pub</span><span class="Token Visibility BraceDepth-1 LPAREN">(</span><span class="Token Keyword Visibility CRATE">crate</span><span class="Token Visibility BraceDepth-1 RPAREN">)</span><span class="Token Visibility SPACE"> </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token Identifier ImplMember FunctionName ID">new</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token Keyword Ty SSELF">Self</span><span class="Token Keyword Ty SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token TypeBound Identifier ExprPathSegment ID">MyFormatter</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token PrimaryGroup Expr SPACE">            </span><span class="Token Identifier StructField ID">pretty_formatter</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment ID">PrettyFormatter</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier ExprPathSegment FunctionCall ID">new</span><span class="Token RefGroup BraceDepth-0 LPAREN">(</span><span class="Token RefGroup BraceDepth-0 RPAREN">)</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">        </span><span class="Token PrimaryGroup Expr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token PrimaryGroup Expr SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 RCURLY_BRACE">}</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token Keyword ImplItem IMPL">impl</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">Formatter</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token Keyword ImplItem FOR">for</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">MyFormatter</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 LCURLY_BRACE">{</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token Identifier ImplMember FunctionName MutableFunction ID">begin_array</span><span class="Token GenericParams ImplMember BraceDepth-1 LANGLE_BRACE">&lt;</span><span class="Token Identifier TyParam GenericType ID">W</span><span class="Token TyParam COLON">:</span><span class="Token TyParam SPACE"> </span><span class="Token QUESTION">?</span><span class="Token Identifier TypePathSegment TypeBound ID">Sized</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token PLUS">+</span><span class="Token SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">Write</span><span class="Token GenericParams ImplMember BraceDepth-1 RANGLE_BRACE">&gt;</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam MUT">mut</span><span class="Token Keyword SelfParam SPACE"> </span><span class="Token Keyword SelfParam MutableSelf SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token Identifier Path MutableArg ID">writer</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Keyword Ty MUT">mut</span><span class="Token Keyword Ty SPACE"> </span><span class="Token Identifier TypePathSegment TypeBound ID">W</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">io</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier TypePathSegment TypeBound ID">Result</span><span class="Token GenericValues TypePathSegment BraceDepth-1 LANGLE_BRACE">&lt;</span><span class="Token Ty TySum BraceDepth-2 LPAREN">(</span><span class="Token Ty TySum BraceDepth-2 RPAREN">)</span><span class="Token GenericValues TypePathSegment BraceDepth-1 RANGLE_BRACE">&gt;</span><span class="Token GenericValues TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token MutableSelf Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">pretty_formatter</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">begin_array</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">writer</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup LF">
</span><span class="Token RefGroup SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token Identifier ImplMember FunctionName MutableFunction ID">end_array</span><span class="Token GenericParams ImplMember BraceDepth-1 LANGLE_BRACE">&lt;</span><span class="Token TypeBound Identifier TyParam GenericType ID">W</span><span class="Token TyParam COLON">:</span><span class="Token TyParam SPACE"> </span><span class="Token QUESTION">?</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Sized</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token PLUS">+</span><span class="Token SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Write</span><span class="Token GenericParams ImplMember BraceDepth-1 RANGLE_BRACE">&gt;</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam MUT">mut</span><span class="Token Keyword SelfParam SPACE"> </span><span class="Token Keyword SelfParam MutableSelf SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token Identifier Path MutableArg ID">writer</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Keyword Ty MUT">mut</span><span class="Token Keyword Ty SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">W</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">io</span><span class="Token DOUBLE_COLON">::</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Result</span><span class="Token GenericValues TypePathSegment BraceDepth-1 LANGLE_BRACE">&lt;</span><span class="Token Ty TySum BraceDepth-2 LPAREN">(</span><span class="Token Ty TySum BraceDepth-2 RPAREN">)</span><span class="Token GenericValues TypePathSegment BraceDepth-1 RANGLE_BRACE">&gt;</span><span class="Token GenericValues TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token MutableSelf Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">pretty_formatter</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">end_array</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">writer</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup LF">
</span><span class="Token RefGroup SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token Identifier ImplMember FunctionName MutableFunction ID">begin_array_value</span><span class="Token GenericParams ImplMember BraceDepth-1 LANGLE_BRACE">&lt;</span><span class="Token TypeBound Identifier TyParam GenericType ID">W</span><span class="Token TyParam COLON">:</span><span class="Token TyParam SPACE"> </span><span class="Token QUESTION">?</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Sized</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token PLUS">+</span><span class="Token SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Write</span><span class="Token GenericParams ImplMember BraceDepth-1 RANGLE_BRACE">&gt;</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token MemberFnParams ImplMember LF">
</span><span class="Token MemberFnParams ImplMember SPACE">        </span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam MUT">mut</span><span class="Token Keyword SelfParam SPACE"> </span><span class="Token Keyword SelfParam MutableSelf SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember LF">
</span><span class="Token MemberFnParams ImplMember SPACE">        </span><span class="Token Identifier Path MutableArg ID">writer</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Keyword Ty MUT">mut</span><span class="Token Keyword Ty SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">W</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">        </span><span class="Token Identifier Path ID">first</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">bool</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">io</span><span class="Token DOUBLE_COLON">::</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Result</span><span class="Token GenericValues TypePathSegment BraceDepth-1 LANGLE_BRACE">&lt;</span><span class="Token Ty TySum BraceDepth-2 LPAREN">(</span><span class="Token Ty TySum BraceDepth-2 RPAREN">)</span><span class="Token GenericValues TypePathSegment BraceDepth-1 RANGLE_BRACE">&gt;</span><span class="Token GenericValues TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token MutableSelf Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">pretty_formatter</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">begin_array_value</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">writer</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">first</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup LF">
</span><span class="Token RefGroup SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token Identifier ImplMember FunctionName MutableFunction ID">end_array_value</span><span class="Token GenericParams ImplMember BraceDepth-1 LANGLE_BRACE">&lt;</span><span class="Token TypeBound Identifier TyParam GenericType ID">W</span><span class="Token TyParam COLON">:</span><span class="Token TyParam SPACE"> </span><span class="Token QUESTION">?</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Sized</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token PLUS">+</span><span class="Token SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Write</span><span class="Token GenericParams ImplMember BraceDepth-1 RANGLE_BRACE">&gt;</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam MUT">mut</span><span class="Token Keyword SelfParam SPACE"> </span><span class="Token Keyword SelfParam MutableSelf SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token Identifier Path MutableArg ID">writer</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Keyword Ty MUT">mut</span><span class="Token Keyword Ty SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">W</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">io</span><span class="Token DOUBLE_COLON">::</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Result</span><span class="Token GenericValues TypePathSegment BraceDepth-1 LANGLE_BRACE">&lt;</span><span class="Token Ty TySum BraceDepth-2 LPAREN">(</span><span class="Token Ty TySum BraceDepth-2 RPAREN">)</span><span class="Token GenericValues TypePathSegment BraceDepth-1 RANGLE_BRACE">&gt;</span><span class="Token GenericValues TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token MutableSelf Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">pretty_formatter</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">end_array_value</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">writer</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup LF">
</span><span class="Token RefGroup SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 RCURLY_BRACE">}</span><span class="Token ImplItem ItemWithAttrs LF">
</span></code></pre><h2 id="h2-5"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/5.rs" target="_blank">5.rs</a></h2><pre class="language-rust"><code><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// Variables can be type annotated.</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">logical</span><span class="Token LetExpr COLON">:</span><span class="Token LetExpr SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">bool</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TRUE">true</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">a_float</span><span class="Token LetExpr COLON">:</span><span class="Token LetExpr SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">f64</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">1.0</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr SPACE">  </span><span class="Token LetExpr COMMENT">// Regular annotation</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">an_integer</span><span class="Token Identifier Path SPACE">   </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number NUMBER">5</span><span class="Token NumberType Number NUMBER">i32</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr SPACE"> </span><span class="Token LetExpr COMMENT">// Suffix annotation</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// Or a default will be used.</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">default_float</span><span class="Token Identifier Path SPACE">   </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">3.0</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr SPACE"> </span><span class="Token LetExpr COMMENT">// `f64`</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">default_integer</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">7</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr SPACE">   </span><span class="Token LetExpr COMMENT">// `i32`</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// A type can also be inferred from context.</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Keyword Pat MUT">mut</span><span class="Token Keyword Pat SPACE"> </span><span class="Token Identifier Pat MutableVar ID">inferred_type</span><span class="Token Identifier Pat SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">12</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr SPACE"> </span><span class="Token LetExpr COMMENT">// Type i64 is inferred from another line.</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token MutableVar Identifier ExprPathSegment ID">inferred_type</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number NUMBER">4294967296</span><span class="Token NumberType Number NUMBER">i64</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// A mutable variable&#x27;s value can be changed.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Keyword Pat MUT">mut</span><span class="Token Keyword Pat SPACE"> </span><span class="Token Identifier Pat MutableVar ID">mutable</span><span class="Token Identifier Pat SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">12</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr SPACE"> </span><span class="Token LetExpr COMMENT">// Mutable `i32`</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token MutableVar Identifier ExprPathSegment ID">mutable</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">21</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Error! The type of a variable can&#x27;t be changed.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token MutableVar Identifier ExprPathSegment ID">mutable</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token TRUE">true</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Variables can be overwritten with shadowing.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">mutable</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TRUE">true</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-6"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/6.rs" target="_blank">6.rs</a></h2><pre class="language-rust"><code><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">fmt</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token PathGlob PathGlob BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Keyword PathGlob SELF">self</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ImportLibName PathGlob ID">Formatter</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ImportLibName PathGlob ID">Display</span><span class="Token PathGlob PathGlob BraceDepth-0 RCURLY_BRACE">}</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">City</span><span class="Token Identifier StructItem ClassName SPACE"> </span><span class="Token RecordStructBody StructItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem SPACE">    </span><span class="Token Identifier RecordStructMember ID">name</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Ty TySum LIFETIME">&#x27;static</span><span class="Token Ty TySum SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">str</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token COMMENT">// Latitude</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier RecordStructMember ID">lat</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">f32</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token COMMENT">// Longitude</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier RecordStructMember ID">lon</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">f32</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token RecordStructBody StructItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token Keyword ImplItem IMPL">impl</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">Display</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token Keyword ImplItem FOR">for</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ClassName Identifier TypePathSegment TypeBound ID">City</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 LCURLY_BRACE">{</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token ImplItem ItemWithAttrs COMMENT">// `f` is a buffer, and this method must write the formatted string into it.</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token ImportLibName Identifier ImplMember FunctionName ID">fmt</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token Identifier Path MutableArg ID">f</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Keyword Ty MUT">mut</span><span class="Token Keyword Ty SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">Formatter</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier TypePathSegment TypeBound ID">Result</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">lat_c</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Keyword IfExpr IF">if</span><span class="Token Keyword IfExpr SPACE"> </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">lat</span><span class="Token Identifier RefGroup SPACE"> </span><span class="Token Punctuator Expr GE">&gt;=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0.0</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token BlockExpr IfExpr SPACE"> </span><span class="Token CHARACTER">&#x27;N&#x27;</span><span class="Token SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token BlockExpr IfExpr SPACE"> </span><span class="Token IfExpr PrimaryGroup ELSE">else</span><span class="Token IfExpr PrimaryGroup SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token BlockExpr IfExpr SPACE"> </span><span class="Token CHARACTER">&#x27;S&#x27;</span><span class="Token SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">        </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">lon_c</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Keyword IfExpr IF">if</span><span class="Token Keyword IfExpr SPACE"> </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">lon</span><span class="Token Identifier RefGroup SPACE"> </span><span class="Token Punctuator Expr GE">&gt;=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0.0</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token BlockExpr IfExpr SPACE"> </span><span class="Token CHARACTER">&#x27;E&#x27;</span><span class="Token SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token BlockExpr IfExpr SPACE"> </span><span class="Token IfExpr PrimaryGroup ELSE">else</span><span class="Token IfExpr PrimaryGroup SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token BlockExpr IfExpr SPACE"> </span><span class="Token CHARACTER">&#x27;W&#x27;</span><span class="Token SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">        </span><span class="Token LetExpr COMMENT">// `write!` is like `format!`, but it will write the formatted string</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">        </span><span class="Token LetExpr COMMENT">// into a buffer (the first argument).</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">        </span><span class="Token Identifier MacroExpr MacroDefine ID">write</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">f</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:.</span><span class="Token String NUMBER">3</span><span class="Token Format String STRING">}</span><span class="Token String STRING">°</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:.</span><span class="Token String NUMBER">3</span><span class="Token Format String STRING">}</span><span class="Token String STRING">°</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">               </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">name</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">lat</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">abs</span><span class="Token RefGroup BraceDepth-0 LPAREN">(</span><span class="Token RefGroup BraceDepth-0 RPAREN">)</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">lat_c</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">lon</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">abs</span><span class="Token RefGroup BraceDepth-0 LPAREN">(</span><span class="Token RefGroup BraceDepth-0 RPAREN">)</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">lon_c</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr LF">
</span><span class="Token MacroExpr Expr SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 RCURLY_BRACE">}</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token OuterAttr HASH">#</span><span class="Token OuterAttr BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier MetaItem Attribute ID">derive</span><span class="Token MetaItem OuterAttr BraceDepth-1 LPAREN">(</span><span class="Token Identifier MetaItem TraitName ID">Debug</span><span class="Token MetaItem OuterAttr BraceDepth-1 RPAREN">)</span><span class="Token OuterAttr BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token OuterAttr LF">
</span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">Color</span><span class="Token Identifier StructItem ClassName SPACE"> </span><span class="Token RecordStructBody StructItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem SPACE">    </span><span class="Token Identifier RecordStructMember ID">red</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">u8</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier RecordStructMember ID">green</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">u8</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier RecordStructMember ID">blue</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">u8</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token RecordStructBody StructItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword ForExpr FOR">for</span><span class="Token Keyword ForExpr SPACE"> </span><span class="Token Identifier Path ID">city</span><span class="Token Identifier Path SPACE"> </span><span class="Token ForExpr IN">in</span><span class="Token ForExpr SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token PrimaryGroup Expr SPACE">        </span><span class="Token TypeBound Identifier ExprPathSegment ID">City</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Identifier StructField ID">name</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token String STRING">&quot;Dublin&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">lat</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">53.347778</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">lon</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number PrimaryGroup NUMBER">6.259722</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token PrimaryGroup Expr COMMA">,</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token PrimaryGroup Expr SPACE">        </span><span class="Token TypeBound Identifier ExprPathSegment ID">City</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Identifier StructField ID">name</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token String STRING">&quot;Oslo&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">lat</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">59.95</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">lon</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">10.75</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token PrimaryGroup Expr COMMA">,</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token PrimaryGroup Expr SPACE">        </span><span class="Token TypeBound Identifier ExprPathSegment ID">City</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Identifier StructField ID">name</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token String STRING">&quot;Vancouver&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">lat</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">49.25</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">lon</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number PrimaryGroup NUMBER">123.1</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token PrimaryGroup Expr COMMA">,</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token PrimaryGroup Expr SPACE">    </span><span class="Token PrimaryGroup Expr BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token BlockExpr ForExpr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">        </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">city</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token BlockExpr ForExpr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">    </span><span class="Token Keyword ForExpr FOR">for</span><span class="Token Keyword ForExpr SPACE"> </span><span class="Token Identifier Path ID">color</span><span class="Token Identifier Path SPACE"> </span><span class="Token ForExpr IN">in</span><span class="Token ForExpr SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token PrimaryGroup Expr SPACE">        </span><span class="Token ClassName Identifier ExprPathSegment ID">Color</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Identifier StructField ID">red</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">128</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">green</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">255</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">blue</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">90</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token PrimaryGroup Expr COMMA">,</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token PrimaryGroup Expr SPACE">        </span><span class="Token ClassName Identifier ExprPathSegment ID">Color</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Identifier StructField ID">red</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">green</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">3</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">blue</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">254</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token PrimaryGroup Expr COMMA">,</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token PrimaryGroup Expr SPACE">        </span><span class="Token ClassName Identifier ExprPathSegment ID">Color</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Identifier StructField ID">red</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">green</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">blue</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token PrimaryGroup Expr COMMA">,</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token PrimaryGroup Expr SPACE">    </span><span class="Token PrimaryGroup Expr BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token BlockExpr ForExpr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">        </span><span class="Token BlockExpr ForExpr COMMENT">// Switch this to use {} once you&#x27;ve added an implementation</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">        </span><span class="Token BlockExpr ForExpr COMMENT">// for fmt::Display.</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">        </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">color</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token BlockExpr ForExpr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-7"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/7.rs" target="_blank">7.rs</a></h2><pre class="language-rust"><code><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// Integer addition</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;1 + 2 = </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">1</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token SPACE"> </span><span class="Token Punctuator Expr PLUS">+</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Integer subtraction</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;1 - 2 = </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">1</span><span class="Token NumberType Number NUMBER">i32</span><span class="Token SPACE"> </span><span class="Token Punctuator Expr MINUS">-</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// TODO ^ Try changing `1i32` to `1u32` to see why the type is important</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Scientific notation</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;1e4 is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">, -2.5e-3 is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">1e4</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number PrimaryGroup NUMBER">2.5e-3</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Short-circuiting boolean logic</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;true AND false is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TRUE">true</span><span class="Token SPACE"> </span><span class="Token Punctuator Expr AND">&amp;&amp;</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token FALSE">false</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;true OR false is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TRUE">true</span><span class="Token SPACE"> </span><span class="Token Punctuator Expr OR">||</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token FALSE">false</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;NOT true is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token UnaryGroup Expr BANG">!</span><span class="Token TRUE">true</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Bitwise operations</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;0011 AND 0101 is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">04b</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">0b0011</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token SPACE"> </span><span class="Token Punctuator Expr AMPERSAND">&amp;</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0b0101</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;0011 OR 0101 is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">04b</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">0b0011</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token SPACE"> </span><span class="Token Punctuator Expr PIPE">|</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0b0101</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;0011 XOR 0101 is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">04b</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">0b0011</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token SPACE"> </span><span class="Token Punctuator Expr CARET">^</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0b0101</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;1 &lt;&lt; 5 is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">1</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token SPACE"> </span><span class="Token Punctuator Expr SHL">&lt;&lt;</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">5</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;0x80 &gt;&gt; 2 is 0x</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">x</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">0x80</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token SPACE"> </span><span class="Token Punctuator Expr SHR">&gt;&gt;</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Use underscores to improve readability!</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;One million is written as </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">1_000_000</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-8"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/8.rs" target="_blank">8.rs</a></h2><pre class="language-rust"><code><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// In general, the `{}` will be automatically replaced with any</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// arguments. These will be stringified.</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> days&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">31</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Positional arguments can be used. Specifying an integer inside `{}`</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// determines which additional argument will be replaced. Arguments start</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// at 0 immediately after the format string.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">0</span><span class="Token Format String STRING">}</span><span class="Token String STRING">, this is </span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">1</span><span class="Token Format String STRING">}</span><span class="Token String STRING">. </span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">1</span><span class="Token Format String STRING">}</span><span class="Token String STRING">, this is </span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">0</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;Alice&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;Bob&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// As can named arguments.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String ID">subject</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> </span><span class="Token Format String STRING">{</span><span class="Token String ID">verb</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> </span><span class="Token Format String STRING">{</span><span class="Token String ID">object</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">             </span><span class="Token Identifier ExprPathSegment ID">object</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token String STRING">&quot;the lazy dog&quot;</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">             </span><span class="Token Identifier ExprPathSegment ID">subject</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token String STRING">&quot;the quick brown fox&quot;</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">             </span><span class="Token Identifier ExprPathSegment ID">verb</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token String STRING">&quot;jumps over&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Different formatting can be invoked by specifying the format character</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// after a `:`.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Base 10:               </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE">   </span><span class="Token Number PrimaryGroup NUMBER">69420</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// 69420</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Base 2 (binary):       </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">b</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">69420</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// 10000111100101100</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Base 8 (octal):        </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">o</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">69420</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// 207454</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Base 16 (hexadecimal): </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">x</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">69420</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// 10f2c</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Base 16 (hexadecimal): </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">X</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">69420</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// 10F2C</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// You can right-justify text with a specified width. This will</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// output &quot;    1&quot;. (Four white spaces and a &quot;1&quot;, for a total width of 5.)</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String ID">number:&gt;5</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">number</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// You can pad numbers with extra zeroes,</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String ID">number:0&gt;5</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">number</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// 00001</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// and left-adjust by flipping the sign. This will output &quot;10000&quot;.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String ID">number:0&lt;5</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">number</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// 10000</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// You can use named arguments in the format specifier by appending a `$`.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String ID">number:0&gt;width$</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">number</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">width</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Number PrimaryGroup NUMBER">5</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Rust even checks to make sure the correct number of arguments are used.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;My name is </span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">0</span><span class="Token Format String STRING">}</span><span class="Token String STRING">, </span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">1</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> </span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">0</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;Bond&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// FIXME ^ Add the missing argument: &quot;James&quot;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Only types that implement fmt::Display can be formatted with `{}`. User-</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// defined types do not implement fmt::Display by default.</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token OuterAttr HASH">#</span><span class="Token OuterAttr BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token Identifier MetaItem Attribute ID">allow</span><span class="Token MetaItem OuterAttr BraceDepth-2 LPAREN">(</span><span class="Token Identifier MetaItem TraitName ID">dead_code</span><span class="Token MetaItem OuterAttr BraceDepth-2 RPAREN">)</span><span class="Token OuterAttr BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token OuterAttr SPACE"> </span><span class="Token OuterAttr COMMENT">// disable `dead_code` which warn against unused module</span><span class="Token OuterAttr LF">
</span><span class="Token OuterAttr SPACE">    </span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">Structure</span><span class="Token TupleStructBody BraceDepth-1 LPAREN">(</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">i32</span><span class="Token TupleStructBody BraceDepth-1 RPAREN">)</span><span class="Token StructItem SEMI">;</span><span class="Token StructItem LF">
</span><span class="Token StructItem LF">
</span><span class="Token StructItem SPACE">    </span><span class="Token StructItem COMMENT">// This will not compile because `Structure` does not implement</span><span class="Token StructItem LF">
</span><span class="Token StructItem SPACE">    </span><span class="Token StructItem COMMENT">// fmt::Display.</span><span class="Token StructItem LF">
</span><span class="Token StructItem SPACE">    </span><span class="Token StructItem COMMENT">// println!(&quot;This struct `{}` won&#x27;t print...&quot;, Structure(3));</span><span class="Token StructItem LF">
</span><span class="Token StructItem SPACE">    </span><span class="Token StructItem COMMENT">// TODO ^ Try uncommenting this line</span><span class="Token StructItem LF">
</span><span class="Token StructItem LF">
</span><span class="Token StructItem SPACE">    </span><span class="Token StructItem COMMENT">// For Rust 1.58 and above, you can directly capture the argument from a</span><span class="Token StructItem LF">
</span><span class="Token StructItem SPACE">    </span><span class="Token StructItem COMMENT">// surrounding variable. Just like the above, this will output</span><span class="Token StructItem LF">
</span><span class="Token StructItem SPACE">    </span><span class="Token StructItem COMMENT">// &quot;    1&quot;, 4 white spaces and a &quot;1&quot;.</span><span class="Token StructItem LF">
</span><span class="Token StructItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">number</span><span class="Token LetExpr COLON">:</span><span class="Token LetExpr SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">f64</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">1.0</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">width</span><span class="Token LetExpr COLON">:</span><span class="Token LetExpr SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">usize</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">5</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String ID">number:&gt;width$</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-9"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/9.rs" target="_blank">9.rs</a></h2><pre class="language-rust"><code><span class="Token COMMENT">// Derive the `fmt::Debug` implementation for `Structure`. `Structure`</span><span class="Token LF">
</span><span class="Token COMMENT">// is a structure which contains a single `i32`.</span><span class="Token LF">
</span><span class="Token OuterAttr HASH">#</span><span class="Token OuterAttr BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier MetaItem Attribute ID">derive</span><span class="Token MetaItem OuterAttr BraceDepth-1 LPAREN">(</span><span class="Token Identifier MetaItem TraitName ID">Debug</span><span class="Token MetaItem OuterAttr BraceDepth-1 RPAREN">)</span><span class="Token OuterAttr BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token OuterAttr LF">
</span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">Structure</span><span class="Token TupleStructBody BraceDepth-0 LPAREN">(</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">i32</span><span class="Token TupleStructBody BraceDepth-0 RPAREN">)</span><span class="Token StructItem ItemWithAttrs SEMI">;</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs COMMENT">// Put a `Structure` inside of the structure `Deep`. Make it printable</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs COMMENT">// also.</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token OuterAttr HASH">#</span><span class="Token OuterAttr BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier MetaItem Attribute ID">derive</span><span class="Token MetaItem OuterAttr BraceDepth-1 LPAREN">(</span><span class="Token Identifier MetaItem TraitName ID">Debug</span><span class="Token MetaItem OuterAttr BraceDepth-1 RPAREN">)</span><span class="Token OuterAttr BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token OuterAttr LF">
</span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">Deep</span><span class="Token TupleStructBody BraceDepth-0 LPAREN">(</span><span class="Token ClassName Identifier TypePathSegment TypeBound ID">Structure</span><span class="Token TupleStructBody BraceDepth-0 RPAREN">)</span><span class="Token StructItem ItemWithAttrs SEMI">;</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// Printing with `{:?}` is similar to with `{}`.</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING"> months in a year.&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">12</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">1:?</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> </span><span class="Token Format String STRING">{</span><span class="Token String NUMBER">0:?</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> is the </span><span class="Token Format String STRING">{</span><span class="Token String ID">actor:?</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> name.&quot;</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">             </span><span class="Token String STRING">&quot;Slater&quot;</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">             </span><span class="Token String STRING">&quot;Christian&quot;</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">             </span><span class="Token Identifier ExprPathSegment ID">actor</span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token String STRING">&quot;actor&#x27;s&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// `Structure` is printable!</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Now </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING"> will print!&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment FunctionCall ID">Structure</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">3</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// The problem with `derive` is there is no control over how</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// the results look. What if I want this to just show a `7`?</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Now </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING"> will print!&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token ClassName Identifier ExprPathSegment FunctionCall ID">Deep</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token TypeBound Identifier ExprPathSegment FunctionCall ID">Structure</span><span class="Token RefGroup BraceDepth-0 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">7</span><span class="Token RefGroup BraceDepth-0 RPAREN">)</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token OuterAttr HASH">#</span><span class="Token OuterAttr BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier MetaItem Attribute ID">derive</span><span class="Token MetaItem OuterAttr BraceDepth-1 LPAREN">(</span><span class="Token Identifier MetaItem TraitName ID">Debug</span><span class="Token MetaItem OuterAttr BraceDepth-1 RPAREN">)</span><span class="Token OuterAttr BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token OuterAttr LF">
</span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">Person</span><span class="Token GenericParams StructItem BraceDepth-0 LANGLE_BRACE">&lt;</span><span class="Token GenericParams StructItem LIFETIME">&#x27;a</span><span class="Token GenericParams StructItem BraceDepth-0 RANGLE_BRACE">&gt;</span><span class="Token GenericParams StructItem SPACE"> </span><span class="Token RecordStructBody StructItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem SPACE">    </span><span class="Token Identifier RecordStructMember ID">name</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Ty TySum LIFETIME">&#x27;a</span><span class="Token Ty TySum SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">str</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier RecordStructMember ID">age</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">u8</span><span class="Token Identifier TypePathSegment LF">
</span><span class="Token RecordStructBody StructItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">func</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">name</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token String STRING">&quot;Peter&quot;</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">age</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">27</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">peter</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token ClassName Identifier ExprPathSegment ID">Person</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Identifier StructField ID">name</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">age</span><span class="Token Identifier StructField SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// Pretty print</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:#?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">peter</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-10"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/10.rs" target="_blank">10.rs</a></h2><pre class="language-rust"><code><span class="Token COMMENT">// Import (via `use`) the `fmt` module to make it available.</span><span class="Token LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">fmt</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs COMMENT">// Define a structure for which `fmt::Display` will be implemented. This is</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs COMMENT">// a tuple struct named `Structure` that contains an `i32`.</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">Structure</span><span class="Token TupleStructBody BraceDepth-0 LPAREN">(</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">i32</span><span class="Token TupleStructBody BraceDepth-0 RPAREN">)</span><span class="Token StructItem ItemWithAttrs SEMI">;</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs COMMENT">// To use the `{}` marker, the trait `fmt::Display` must be implemented</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs COMMENT">// manually for the type.</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token Keyword ImplItem IMPL">impl</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier TypePathSegment TypeBound ID">Display</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token Keyword ImplItem FOR">for</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ClassName Identifier TypePathSegment TypeBound ID">Structure</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 LCURLY_BRACE">{</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token ImplItem ItemWithAttrs COMMENT">// This trait requires `fmt` with this exact signature.</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token TypeBound Identifier ImplMember FunctionName ID">fmt</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token Identifier Path MutableArg ID">f</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Keyword Ty MUT">mut</span><span class="Token Keyword Ty SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier TypePathSegment TypeBound ID">Formatter</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier TypePathSegment TypeBound ID">Result</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// Write strictly the first element into the supplied output</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// stream: `f`. Returns `fmt::Result` which indicates whether the</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// operation succeeded or failed. Note that `write!` uses syntax which</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// is very similar to `println!`.</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token Identifier MacroExpr MacroDefine ID">write</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">f</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token RefGroup NUMBER">0</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr LF">
</span><span class="Token MacroExpr Expr SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 RCURLY_BRACE">}</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token TypeBound Identifier ImportLibName PathGlob ID">fmt</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs SPACE"> </span><span class="Token UseItem ItemWithAttrs COMMENT">// Import `fmt`</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs COMMENT">// A structure holding two numbers. `Debug` will be derived so the results can</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs COMMENT">// be contrasted with `Display`.</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token OuterAttr HASH">#</span><span class="Token OuterAttr BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier MetaItem Attribute ID">derive</span><span class="Token MetaItem OuterAttr BraceDepth-1 LPAREN">(</span><span class="Token Identifier MetaItem TraitName ID">Debug</span><span class="Token MetaItem OuterAttr BraceDepth-1 RPAREN">)</span><span class="Token OuterAttr BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token OuterAttr LF">
</span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">MinMax</span><span class="Token TupleStructBody BraceDepth-0 LPAREN">(</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">i64</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">i64</span><span class="Token TupleStructBody BraceDepth-0 RPAREN">)</span><span class="Token StructItem ItemWithAttrs SEMI">;</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs COMMENT">// Implement `Display` for `MinMax`.</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token Keyword ImplItem IMPL">impl</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Display</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token Keyword ImplItem FOR">for</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ClassName Identifier TypePathSegment TypeBound ID">MinMax</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 LCURLY_BRACE">{</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token TypeBound Identifier ImplMember FunctionName ID">fmt</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token Identifier Path MutableArg ID">f</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Keyword Ty MUT">mut</span><span class="Token Keyword Ty SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Formatter</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Result</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// Use `self.number` to refer to each positional data point.</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token Identifier MacroExpr MacroDefine ID">write</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">f</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;(</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">, </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">)&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token RefGroup NUMBER">0</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token RefGroup NUMBER">1</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr LF">
</span><span class="Token MacroExpr Expr SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 RCURLY_BRACE">}</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs COMMENT">// Define a structure where the fields are nameable for comparison.</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token OuterAttr HASH">#</span><span class="Token OuterAttr BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier MetaItem Attribute ID">derive</span><span class="Token MetaItem OuterAttr BraceDepth-1 LPAREN">(</span><span class="Token Identifier MetaItem TraitName ID">Debug</span><span class="Token MetaItem OuterAttr BraceDepth-1 RPAREN">)</span><span class="Token OuterAttr BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token OuterAttr LF">
</span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">Point2D</span><span class="Token Identifier StructItem ClassName SPACE"> </span><span class="Token RecordStructBody StructItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem SPACE">    </span><span class="Token Identifier RecordStructMember ID">x</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">f64</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier RecordStructMember ID">y</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">f64</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token RecordStructBody StructItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token RecordStructBody StructItem COMMENT">// Similarly, implement `Display` for `Point2D`.</span><span class="Token RecordStructBody StructItem LF">
</span><span class="Token Keyword ImplItem IMPL">impl</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Display</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token Keyword ImplItem FOR">for</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ClassName Identifier TypePathSegment TypeBound ID">Point2D</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 LCURLY_BRACE">{</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token TypeBound Identifier ImplMember FunctionName ID">fmt</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token Identifier Path MutableArg ID">f</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Keyword Ty MUT">mut</span><span class="Token Keyword Ty SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Formatter</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">Result</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// Customize so only `x` and `y` are denoted.</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token Identifier MacroExpr MacroDefine ID">write</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">f</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;x: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">, y: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">x</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup ID">y</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr LF">
</span><span class="Token MacroExpr Expr SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 RCURLY_BRACE">}</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">minmax</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment FunctionCall ID">MinMax</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">14</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Compare structures:&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Display: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">minmax</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Debug: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">minmax</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">big_range</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE">   </span><span class="Token TypeBound Identifier ExprPathSegment FunctionCall ID">MinMax</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number PrimaryGroup NUMBER">300</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">300</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">small_range</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment FunctionCall ID">MinMax</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number PrimaryGroup NUMBER">3</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">3</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;The big range is </span><span class="Token Format String STRING">{</span><span class="Token String ID">big</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> and the small is </span><span class="Token Format String STRING">{</span><span class="Token String ID">small</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">             </span><span class="Token Identifier ExprPathSegment ID">small</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">small_range</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">             </span><span class="Token Identifier ExprPathSegment ID">big</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">big_range</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">point</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment ID">Point2D</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Identifier StructField ID">x</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">3.3</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">y</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">7.2</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Compare points:&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Display: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">point</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Debug: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">point</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Error. Both `Debug` and `Display` were implemented, but `{:b}`</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// requires `fmt::Binary` to be implemented. This will not work.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// println!(&quot;What does Point2D look like in binary: {:b}?&quot;, point);</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-11"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/11.rs" target="_blank">11.rs</a></h2><pre class="language-rust"><code><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">fmt</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs SPACE"> </span><span class="Token UseItem ItemWithAttrs COMMENT">// Import the `fmt` module.</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs COMMENT">// Define a structure named `List` containing a `Vec`.</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">List</span><span class="Token TupleStructBody BraceDepth-0 LPAREN">(</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">Vec</span><span class="Token GenericValues TypePathSegment BraceDepth-1 LANGLE_BRACE">&lt;</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">i32</span><span class="Token GenericValues TypePathSegment BraceDepth-1 RANGLE_BRACE">&gt;</span><span class="Token TupleStructBody BraceDepth-0 RPAREN">)</span><span class="Token StructItem ItemWithAttrs SEMI">;</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token Keyword ImplItem IMPL">impl</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier TypePathSegment TypeBound ID">Display</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token Keyword ImplItem FOR">for</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token ClassName Identifier TypePathSegment TypeBound ID">List</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 LCURLY_BRACE">{</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token TypeBound Identifier ImplMember FunctionName ID">fmt</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token Identifier Path MutableArg ID">f</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Keyword Ty MUT">mut</span><span class="Token Keyword Ty SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier TypePathSegment TypeBound ID">Formatter</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">fmt</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier TypePathSegment TypeBound ID">Result</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// Extract the value using tuple indexing,</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// and create a reference to `vec`.</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">vec</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token UnaryGroup Expr AMPERSAND">&amp;</span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup DOT">.</span><span class="Token RefGroup NUMBER">0</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">        </span><span class="Token Identifier MacroExpr MacroDefine ID">write</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">f</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;[&quot;</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token Expr QUESTION">?</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">        </span><span class="Token Expr COMMENT">// Iterate over `v` in `vec` while enumerating the iteration</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">        </span><span class="Token Expr COMMENT">// count in `count`.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">        </span><span class="Token Keyword ForExpr FOR">for</span><span class="Token Keyword ForExpr SPACE"> </span><span class="Token Pat ForExpr BraceDepth-2 LPAREN">(</span><span class="Token Identifier Path ID">count</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier Path ID">v</span><span class="Token Pat ForExpr BraceDepth-2 RPAREN">)</span><span class="Token Pat ForExpr SPACE"> </span><span class="Token ForExpr IN">in</span><span class="Token ForExpr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">vec</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">iter</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">enumerate</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup SPACE"> </span><span class="Token BlockExpr ForExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">            </span><span class="Token BlockExpr ForExpr COMMENT">// For every element except the first, add a comma.</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">            </span><span class="Token BlockExpr ForExpr COMMENT">// Use the ? operator to return on errors.</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">            </span><span class="Token Keyword IfExpr IF">if</span><span class="Token Keyword IfExpr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">count</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr NE">!=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr IfExpr SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">write</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">f</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;, &quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr QUESTION">?</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-0 RCURLY_BRACE">}</span><span class="Token BlockExpr IfExpr LF">
</span><span class="Token BlockExpr IfExpr SPACE">            </span><span class="Token Identifier MacroExpr MacroDefine ID">write</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-0 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">f</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">v</span><span class="Token MacroExpr Expr BraceDepth-0 RPAREN">)</span><span class="Token Expr QUESTION">?</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">        </span><span class="Token BlockExpr ForExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">        </span><span class="Token BlockExpr ForExpr COMMENT">// Close the opened bracket and return a fmt::Result value.</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">        </span><span class="Token Identifier MacroExpr MacroDefine ID">write</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token MutableVar Identifier ExprPathSegment ID">f</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;]&quot;</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr LF">
</span><span class="Token MacroExpr Expr SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 RCURLY_BRACE">}</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">v</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment FunctionCall ID">List</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Identifier MacroExpr MacroDefine ID">vec</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LSQUAR_PAREN">[</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">3</span><span class="Token MacroExpr Expr BraceDepth-2 RSQUAR_PAREN">]</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">v</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-12"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/12.rs" target="_blank">12.rs</a></h2><pre class="language-rust"><code><span class="Token COMMENT">// Tuples can be used as function arguments and as return values.</span><span class="Token LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">reverse</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token Identifier Path ID">pair</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum BraceDepth-1 LPAREN">(</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">i32</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">bool</span><span class="Token Ty TySum BraceDepth-1 RPAREN">)</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token RetTy FnItem POINT">-&gt;</span><span class="Token RetTy FnItem SPACE"> </span><span class="Token Ty RetTy BraceDepth-0 LPAREN">(</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">bool</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">i32</span><span class="Token Ty RetTy BraceDepth-0 RPAREN">)</span><span class="Token Ty RetTy SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// `let` can be used to bind the members of a tuple to variables.</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Pat LetExpr BraceDepth-1 LPAREN">(</span><span class="Token Identifier Path ID">int_param</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier Path ID">bool_param</span><span class="Token Pat LetExpr BraceDepth-1 RPAREN">)</span><span class="Token Pat LetExpr SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">pair</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token PrimaryGroup Expr BraceDepth-1 LPAREN">(</span><span class="Token Identifier ExprPathSegment ID">bool_param</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">int_param</span><span class="Token PrimaryGroup Expr BraceDepth-1 RPAREN">)</span><span class="Token PrimaryGroup Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem COMMENT">// The following struct is for the activity.</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token OuterAttr HASH">#</span><span class="Token OuterAttr BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier MetaItem Attribute ID">derive</span><span class="Token MetaItem OuterAttr BraceDepth-1 LPAREN">(</span><span class="Token Identifier MetaItem TraitName ID">Debug</span><span class="Token MetaItem OuterAttr BraceDepth-1 RPAREN">)</span><span class="Token OuterAttr BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token OuterAttr LF">
</span><span class="Token Keyword StructItem STRUCT">struct</span><span class="Token Keyword StructItem SPACE"> </span><span class="Token Identifier StructItem ClassName ID">Matrix</span><span class="Token TupleStructBody BraceDepth-0 LPAREN">(</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">f32</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">f32</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">f32</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">f32</span><span class="Token TupleStructBody BraceDepth-0 RPAREN">)</span><span class="Token StructItem ItemWithAttrs SEMI">;</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token StructItem ItemWithAttrs LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// A tuple with a bunch of different types.</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">long_tuple</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">1u8</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2u16</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">3</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">4</span><span class="Token NumberType Number NUMBER">u64</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">                      </span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number PrimaryGroup NUMBER">1i8</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number PrimaryGroup NUMBER">2i16</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number NUMBER">3</span><span class="Token NumberType Number NUMBER">i32</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number NUMBER">4</span><span class="Token NumberType Number NUMBER">i64</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">                      </span><span class="Token Number PrimaryGroup NUMBER">0.1f32</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0.2f64</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">                      </span><span class="Token CHARACTER">&#x27;a&#x27;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TRUE">true</span><span class="Token PrimaryGroup Expr BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// Values can be extracted from the tuple using tuple indexing.</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Long tuple first value: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">long_tuple</span><span class="Token RefGroup DOT">.</span><span class="Token RefGroup NUMBER">0</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Long tuple second value: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">long_tuple</span><span class="Token RefGroup DOT">.</span><span class="Token RefGroup NUMBER">1</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Tuples can be tuple members.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">tuple_of_tuples</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LPAREN">(</span><span class="Token PrimaryGroup Expr BraceDepth-2 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">1u8</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2u16</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number NUMBER">2</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token PrimaryGroup Expr BraceDepth-2 RPAREN">)</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 LPAREN">(</span><span class="Token Number NUMBER">4</span><span class="Token NumberType Number NUMBER">u64</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number PrimaryGroup NUMBER">1i8</span><span class="Token PrimaryGroup Expr BraceDepth-2 RPAREN">)</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token UnaryGroup Expr MINUS">-</span><span class="Token Number PrimaryGroup NUMBER">2i16</span><span class="Token PrimaryGroup Expr BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// Tuples are printable.</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;tuple of tuples: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">tuple_of_tuples</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// But long Tuples (more than 12 elements) cannot be printed.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">//let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">//println!(&quot;Too long tuple: {:?}&quot;, too_long_tuple);</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// TODO ^ Uncomment the above 2 lines to see the compiler error</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">pair</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TRUE">true</span><span class="Token PrimaryGroup Expr BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Pair is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">pair</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;The reversed pair is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment FunctionCall ID">reverse</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token Identifier ExprPathSegment ID">pair</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// To create one element tuples, the comma is required to tell them apart</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// from a literal surrounded by parentheses.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;One element tuple: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 LPAREN">(</span><span class="Token Number NUMBER">5</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token COMMA">,</span><span class="Token PrimaryGroup Expr BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Just an integer: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-2 LPAREN">(</span><span class="Token Number NUMBER">5</span><span class="Token NumberType Number NUMBER">u32</span><span class="Token PrimaryGroup Expr BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Tuples can be destructured to create bindings.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token ImportLibName Identifier Path ID">tuple</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;hello&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">4.5</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TRUE">true</span><span class="Token PrimaryGroup Expr BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Pat LetExpr BraceDepth-1 LPAREN">(</span><span class="Token Identifier Path ID">a</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier Path ID">b</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier Path ID">c</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier Path ID">d</span><span class="Token Pat LetExpr BraceDepth-1 RPAREN">)</span><span class="Token Pat LetExpr SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token ImportLibName Identifier ExprPathSegment ID">tuple</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">, </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">, </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">, </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">a</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">b</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">c</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">d</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">matrix</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token ClassName Identifier ExprPathSegment FunctionCall ID">Matrix</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">1.1</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">1.2</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2.1</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2.2</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:?</span><span class="Token String NUMBER"></span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">matrix</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-13"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/13.rs" target="_blank">13.rs</a></h2><pre class="language-rust"><code><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token ImportLibName Identifier ImportLibName PathGlob ID">std</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">mem</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs COMMENT">// This function borrows a slice.</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">analyze_slice</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token Identifier Path ID">slice</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Ty TySum AMPERSAND">&amp;</span><span class="Token Ty Ty BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">i32</span><span class="Token Ty Ty BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;First element of the slice: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">slice</span><span class="Token RefGroup BraceDepth-2 LSQUAR_PAREN">[</span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token RefGroup BraceDepth-2 RSQUAR_PAREN">]</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;The slice has </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> elements&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">slice</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">len</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// Fixed-size array (type signature is superfluous).</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">xs</span><span class="Token LetExpr COLON">:</span><span class="Token LetExpr SPACE"> </span><span class="Token Ty TySum BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">i32</span><span class="Token Ty TySum SEMI">;</span><span class="Token Ty TySum SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">5</span><span class="Token Ty TySum BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token Ty TySum SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token PrimaryGroup Expr COMMA">,</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">2</span><span class="Token PrimaryGroup Expr COMMA">,</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">3</span><span class="Token PrimaryGroup Expr COMMA">,</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">4</span><span class="Token PrimaryGroup Expr COMMA">,</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">5</span><span class="Token PrimaryGroup Expr BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// All elements can be initialized to the same value.</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">ys</span><span class="Token LetExpr COLON">:</span><span class="Token LetExpr SPACE"> </span><span class="Token Ty TySum BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">i32</span><span class="Token Ty TySum SEMI">;</span><span class="Token Ty TySum SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">500</span><span class="Token Ty TySum BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token Ty TySum SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token PrimaryGroup Expr SEMI">;</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">500</span><span class="Token PrimaryGroup Expr BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// Indexing starts at 0.</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;First element of the array: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">xs</span><span class="Token RefGroup BraceDepth-2 LSQUAR_PAREN">[</span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token RefGroup BraceDepth-2 RSQUAR_PAREN">]</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Second element of the array: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">xs</span><span class="Token RefGroup BraceDepth-2 LSQUAR_PAREN">[</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token RefGroup BraceDepth-2 RSQUAR_PAREN">]</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// `len` returns the count of elements in the array.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Number of elements in array: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">xs</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">len</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Arrays are stack allocated.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Array occupies </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> bytes&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token ImportLibName Identifier ExprPathSegment ID">mem</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier ExprPathSegment FunctionCall ID">size_of_val</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token UnaryGroup Expr AMPERSAND">&amp;</span><span class="Token Identifier ExprPathSegment ID">xs</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Arrays can be automatically borrowed as slices.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Borrow the whole array as a slice.&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier ExprPathSegment FunctionCall ID">analyze_slice</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token UnaryGroup Expr AMPERSAND">&amp;</span><span class="Token Identifier ExprPathSegment ID">xs</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Slices can point to a section of an array.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// They are of the form [starting_index..ending_index].</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// `starting_index` is the first position in the slice.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// `ending_index` is one more than the last position in the slice.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Borrow a section of the array as a slice.&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier ExprPathSegment FunctionCall ID">analyze_slice</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token UnaryGroup Expr AMPERSAND">&amp;</span><span class="Token Identifier ExprPathSegment ID">ys</span><span class="Token RefGroup BraceDepth-2 LSQUAR_PAREN">[</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token Punctuator Expr CONCAT">..</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">4</span><span class="Token RefGroup BraceDepth-2 RSQUAR_PAREN">]</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Example of empty slice `&amp;[]`:</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">empty_array</span><span class="Token LetExpr COLON">:</span><span class="Token LetExpr SPACE"> </span><span class="Token Ty TySum BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">u32</span><span class="Token Ty TySum SEMI">;</span><span class="Token Ty TySum SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token Ty TySum BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token Ty TySum SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token PrimaryGroup Expr BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">assert_eq</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token UnaryGroup Expr AMPERSAND">&amp;</span><span class="Token Identifier ExprPathSegment ID">empty_array</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token UnaryGroup Expr AMPERSAND">&amp;</span><span class="Token PrimaryGroup Expr BraceDepth-2 LSQUAR_PAREN">[</span><span class="Token PrimaryGroup Expr BraceDepth-2 RSQUAR_PAREN">]</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">assert_eq</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token UnaryGroup Expr AMPERSAND">&amp;</span><span class="Token Identifier ExprPathSegment ID">empty_array</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token UnaryGroup Expr AMPERSAND">&amp;</span><span class="Token PrimaryGroup Expr BraceDepth-2 LSQUAR_PAREN">[</span><span class="Token PrimaryGroup Expr BraceDepth-2 RSQUAR_PAREN">]</span><span class="Token RefGroup BraceDepth-2 LSQUAR_PAREN">[</span><span class="Token RefGroup CONCAT">..</span><span class="Token RefGroup BraceDepth-2 RSQUAR_PAREN">]</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr SPACE"> </span><span class="Token Expr COMMENT">// Same but more verbose</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Arrays can be safely accessed using `.get`, which returns an</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// `Option`. This can be matched as shown below, or used with</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// `.expect()` if you would like the program to exit with a nice</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// message instead of happily continue.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Keyword ForExpr FOR">for</span><span class="Token Keyword ForExpr SPACE"> </span><span class="Token Identifier Path ID">i</span><span class="Token Identifier Path SPACE"> </span><span class="Token ForExpr IN">in</span><span class="Token ForExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token Punctuator Expr CONCAT">..</span><span class="Token Identifier ExprPathSegment ID">xs</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">len</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token RefGroup SPACE"> </span><span class="Token Punctuator Expr PLUS">+</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token BlockExpr ForExpr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ForExpr SPACE"> </span><span class="Token BlockExpr ForExpr COMMENT">// Oops, one element too far!</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">        </span><span class="Token Keyword MatchExpr MATCH">match</span><span class="Token Keyword MatchExpr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">xs</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">get</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token Identifier ExprPathSegment ID">i</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup SPACE"> </span><span class="Token MatchExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">            </span><span class="Token ImportLibName Identifier Path ID">Some</span><span class="Token Pat BraceDepth-0 LPAREN">(</span><span class="Token Identifier Path ID">xval</span><span class="Token Pat BraceDepth-0 RPAREN">)</span><span class="Token Pat SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-0 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">i</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">xval</span><span class="Token MacroExpr Expr BraceDepth-0 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">            </span><span class="Token ImportLibName Identifier Path ID">None</span><span class="Token Identifier Path SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-0 LPAREN">(</span><span class="Token String STRING">&quot;Slow down! </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> is too far!&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">i</span><span class="Token MacroExpr Expr BraceDepth-0 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token MatchExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">    </span><span class="Token BlockExpr ForExpr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">    </span><span class="Token BlockExpr ForExpr COMMENT">// Out of bound indexing on array causes compile time error.</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">    </span><span class="Token BlockExpr ForExpr COMMENT">//println!(&quot;{}&quot;, xs[5]);</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">    </span><span class="Token BlockExpr ForExpr COMMENT">// Out of bound indexing on slice causes runtime error.</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr ForExpr SPACE">    </span><span class="Token BlockExpr ForExpr COMMENT">//println!(&quot;{}&quot;, xs[..][5]);</span><span class="Token BlockExpr ForExpr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-14"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/14.rs" target="_blank">14.rs</a></h2><pre class="language-rust"><code><span class="Token COMMENT">// Create an `enum` to classify a web event. Note how both</span><span class="Token LF">
</span><span class="Token COMMENT">// names and type information together specify the variant:</span><span class="Token LF">
</span><span class="Token COMMENT">// `PageLoad != PageUnload` and `KeyPress(char) != Paste(String)`.</span><span class="Token LF">
</span><span class="Token COMMENT">// Each is different and independent.</span><span class="Token LF">
</span><span class="Token Keyword EnumItem ENUM">enum</span><span class="Token Keyword EnumItem SPACE"> </span><span class="Token Identifier EnumItem Enumerator ID">WebEvent</span><span class="Token Identifier EnumItem Enumerator SPACE"> </span><span class="Token EnumBody EnumItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem SPACE">    </span><span class="Token EnumBody EnumItem COMMENT">// An `enum` variant may either be `unit-like`,</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">PageLoad</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">PageUnload</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token COMMENT">// like tuple structs,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">KeyPress</span><span class="Token TupleStructBody BraceDepth-1 LPAREN">(</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">char</span><span class="Token TupleStructBody BraceDepth-1 RPAREN">)</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Paste</span><span class="Token TupleStructBody BraceDepth-1 LPAREN">(</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">String</span><span class="Token TupleStructBody BraceDepth-1 RPAREN">)</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token COMMENT">// or c-like structures.</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Click</span><span class="Token Identifier EnumMember EnumID SPACE"> </span><span class="Token RecordStructBody EnumMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token RecordStructBody EnumMember SPACE"> </span><span class="Token Identifier RecordStructMember ID">x</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">i64</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier RecordStructMember ID">y</span><span class="Token RecordStructMember COLON">:</span><span class="Token RecordStructMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">i64</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token RecordStructBody EnumMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token EnumBody EnumItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem COMMENT">// A function which takes a `WebEvent` enum as an argument and</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem COMMENT">// returns nothing.</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">inspect</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token Identifier Path ID">event</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token Enumerator Identifier TypePathSegment TypeBound ID">WebEvent</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword MatchExpr MATCH">match</span><span class="Token Keyword MatchExpr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">event</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token MatchExpr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">        </span><span class="Token TypeBound Identifier Path ID">WebEvent</span><span class="Token Path Pat DOUBLE_COLON">::</span><span class="Token EnumID Identifier ID">PageLoad</span><span class="Token Identifier SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;page loaded&quot;</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token TypeBound Identifier Path ID">WebEvent</span><span class="Token Path Pat DOUBLE_COLON">::</span><span class="Token EnumID Identifier ID">PageUnload</span><span class="Token Identifier SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;page unloaded&quot;</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token MatchItem COMMENT">// Destructure `c` from inside the `enum` variant.</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token TypeBound Identifier Path ID">WebEvent</span><span class="Token Path Pat DOUBLE_COLON">::</span><span class="Token EnumID Identifier ID">KeyPress</span><span class="Token Pat BraceDepth-2 LPAREN">(</span><span class="Token Identifier Path ID">c</span><span class="Token Pat BraceDepth-2 RPAREN">)</span><span class="Token Pat SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;pressed &#x27;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&#x27;.&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">c</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token TypeBound Identifier Path ID">WebEvent</span><span class="Token Path Pat DOUBLE_COLON">::</span><span class="Token EnumID Identifier ID">Paste</span><span class="Token Pat BraceDepth-2 LPAREN">(</span><span class="Token Identifier Path ID">s</span><span class="Token Pat BraceDepth-2 RPAREN">)</span><span class="Token Pat SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;pasted \&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">\&quot;.&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">s</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token MatchItem COMMENT">// Destructure `Click` into `x` and `y`.</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token TypeBound Identifier Path ID">WebEvent</span><span class="Token Path Pat DOUBLE_COLON">::</span><span class="Token EnumID Identifier ID">Click</span><span class="Token Identifier SPACE"> </span><span class="Token Pat BraceDepth-2 LCURLY_BRACE">{</span><span class="Token Pat SPACE"> </span><span class="Token Identifier PatField ID">x</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier PatField ID">y</span><span class="Token Identifier PatField SPACE"> </span><span class="Token Pat BraceDepth-2 RCURLY_BRACE">}</span><span class="Token Pat SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token BlockExpr MatchItem BraceDepth-2 LCURLY_BRACE">{</span><span class="Token BlockExpr MatchItem LF">
</span><span class="Token BlockExpr MatchItem SPACE">            </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-0 LPAREN">(</span><span class="Token String STRING">&quot;clicked at x=</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">, y=</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">.&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">x</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">y</span><span class="Token MacroExpr Expr BraceDepth-0 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">        </span><span class="Token BlockExpr MatchItem BraceDepth-2 RCURLY_BRACE">}</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">    </span><span class="Token MatchExpr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token MatchExpr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">pressed</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment ID">WebEvent</span><span class="Token DOUBLE_COLON">::</span><span class="Token EnumID Identifier ExprPathSegment FunctionCall ID">KeyPress</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token CHARACTER">&#x27;x&#x27;</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// `to_owned()` creates an owned `String` from a string slice.</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">pasted</span><span class="Token Identifier Path SPACE">  </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment ID">WebEvent</span><span class="Token DOUBLE_COLON">::</span><span class="Token EnumID Identifier ExprPathSegment FunctionCall ID">Paste</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;my text&quot;</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">to_owned</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">click</span><span class="Token Identifier Path SPACE">   </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment ID">WebEvent</span><span class="Token DOUBLE_COLON">::</span><span class="Token EnumID Identifier ExprPathSegment ID">Click</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token PrimaryGroup Expr SPACE"> </span><span class="Token Identifier StructField ID">x</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">20</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier StructField ID">y</span><span class="Token StructField COLON">:</span><span class="Token StructField SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">80</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token PrimaryGroup Expr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">load</span><span class="Token Identifier Path SPACE">    </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment ID">WebEvent</span><span class="Token DOUBLE_COLON">::</span><span class="Token EnumID Identifier ExprPathSegment ID">PageLoad</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">unload</span><span class="Token Identifier Path SPACE">  </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment ID">WebEvent</span><span class="Token DOUBLE_COLON">::</span><span class="Token EnumID Identifier ExprPathSegment ID">PageUnload</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier ExprPathSegment FunctionCall ID">inspect</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Identifier ExprPathSegment ID">pressed</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier ExprPathSegment FunctionCall ID">inspect</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Identifier ExprPathSegment ID">pasted</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier ExprPathSegment FunctionCall ID">inspect</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Identifier ExprPathSegment ID">click</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier ExprPathSegment FunctionCall ID">inspect</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Identifier ExprPathSegment ID">load</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier ExprPathSegment FunctionCall ID">inspect</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Identifier ExprPathSegment ID">unload</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token Keyword EnumItem ENUM">enum</span><span class="Token Keyword EnumItem SPACE"> </span><span class="Token Identifier EnumItem Enumerator ID">VeryVerboseEnumOfThingsToDoWithNumbers</span><span class="Token Identifier EnumItem Enumerator SPACE"> </span><span class="Token EnumBody EnumItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Add</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Subtract</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token EnumBody EnumItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem COMMENT">// Creates a type alias</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token Keyword TypeItem TYPE">type</span><span class="Token Keyword TypeItem SPACE"> </span><span class="Token Identifier TypeItem Typedefine ID">Operations</span><span class="Token Identifier TypeItem Typedefine SPACE"> </span><span class="Token TypeItem ItemWithAttrs ASSIGN">=</span><span class="Token TypeItem ItemWithAttrs SPACE"> </span><span class="Token Enumerator Identifier TypePathSegment TypeBound ID">VeryVerboseEnumOfThingsToDoWithNumbers</span><span class="Token TypeItem ItemWithAttrs SEMI">;</span><span class="Token TypeItem ItemWithAttrs LF">
</span><span class="Token TypeItem ItemWithAttrs LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// We can refer to each variant via its alias, not its long and inconvenient</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// name.</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">x</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Typedefine Identifier ExprPathSegment ID">Operations</span><span class="Token DOUBLE_COLON">::</span><span class="Token EnumID Identifier ExprPathSegment ID">Add</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token Keyword EnumItem ENUM">enum</span><span class="Token Keyword EnumItem SPACE"> </span><span class="Token TypeBound Identifier EnumItem Enumerator ID">VeryVerboseEnumOfThingsToDoWithNumbers</span><span class="Token Identifier EnumItem Enumerator SPACE"> </span><span class="Token EnumBody EnumItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem SPACE">    </span><span class="Token EnumID Identifier EnumMember EnumID ID">Add</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token EnumID Identifier EnumMember EnumID ID">Subtract</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token EnumBody EnumItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token Keyword ImplItem IMPL">impl</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token Enumerator Identifier TypePathSegment TypeBound ID">VeryVerboseEnumOfThingsToDoWithNumbers</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 LCURLY_BRACE">{</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token Identifier ImplMember FunctionName ID">run</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token Identifier Path ID">x</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">i32</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier Path ID">y</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">i32</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">i32</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token Keyword MatchExpr MATCH">match</span><span class="Token Keyword MatchExpr SPACE"> </span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token Keyword PrimaryGroup SPACE"> </span><span class="Token MatchExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">            </span><span class="Token Keyword Path SSELF">Self</span><span class="Token Path Pat DOUBLE_COLON">::</span><span class="Token EnumID Identifier ID">Add</span><span class="Token Identifier SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier ExprPathSegment ID">x</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr PLUS">+</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">y</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">            </span><span class="Token Keyword Path SSELF">Self</span><span class="Token Path Pat DOUBLE_COLON">::</span><span class="Token EnumID Identifier ID">Subtract</span><span class="Token Identifier SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier ExprPathSegment ID">x</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr MINUS">-</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">y</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token MatchExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-15"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/15.rs" target="_blank">15.rs</a></h2><pre class="language-rust"><code><span class="Token COMMENT">// An attribute to hide warnings for unused code.</span><span class="Token LF">
</span><span class="Token InnerAttr HASH_BANG">#!</span><span class="Token InnerAttr BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier MetaItem Attribute ID">allow</span><span class="Token MetaItem InnerAttr BraceDepth-1 LPAREN">(</span><span class="Token Identifier MetaItem TraitName ID">dead_code</span><span class="Token MetaItem InnerAttr BraceDepth-1 RPAREN">)</span><span class="Token InnerAttr BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token InnerAttr LF">
</span><span class="Token InnerAttr LF">
</span><span class="Token Keyword EnumItem ENUM">enum</span><span class="Token Keyword EnumItem SPACE"> </span><span class="Token Identifier EnumItem Enumerator ID">Status</span><span class="Token Identifier EnumItem Enumerator SPACE"> </span><span class="Token EnumBody EnumItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Rich</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Poor</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token EnumBody EnumItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token Keyword EnumItem ENUM">enum</span><span class="Token Keyword EnumItem SPACE"> </span><span class="Token Identifier EnumItem Enumerator ID">Work</span><span class="Token Identifier EnumItem Enumerator SPACE"> </span><span class="Token EnumBody EnumItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Civilian</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Soldier</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token EnumBody EnumItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// Explicitly `use` each name so they are available without</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// manual scoping.</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token Keyword PathGlob CRATE">crate</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Enumerator Identifier ImportLibName PathGlob ID">Status</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token PathGlob PathGlob BraceDepth-1 LCURLY_BRACE">{</span><span class="Token EnumID Identifier ImportLibName PathGlob ID">Poor</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token EnumID Identifier ImportLibName PathGlob ID">Rich</span><span class="Token PathGlob PathGlob BraceDepth-1 RCURLY_BRACE">}</span><span class="Token UseItem SEMI">;</span><span class="Token UseItem LF">
</span><span class="Token UseItem SPACE">    </span><span class="Token UseItem COMMENT">// Automatically `use` each name inside `Work`.</span><span class="Token UseItem LF">
</span><span class="Token UseItem SPACE">    </span><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token Keyword PathGlob CRATE">crate</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Enumerator Identifier ImportLibName PathGlob ID">Work</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token PathGlob PathGlob DEREF">*</span><span class="Token UseItem SEMI">;</span><span class="Token UseItem LF">
</span><span class="Token UseItem LF">
</span><span class="Token UseItem SPACE">    </span><span class="Token UseItem COMMENT">// Equivalent to `Status::Poor`.</span><span class="Token UseItem LF">
</span><span class="Token UseItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">status</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token EnumID Identifier ExprPathSegment ID">Poor</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// Equivalent to `Work::Civilian`.</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">work</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token EnumID Identifier ExprPathSegment ID">Civilian</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Keyword MatchExpr MATCH">match</span><span class="Token Keyword MatchExpr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">status</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token MatchExpr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">        </span><span class="Token MatchExpr COMMENT">// Note the lack of scoping because of the explicit `use` above.</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">        </span><span class="Token EnumID Identifier Path ID">Rich</span><span class="Token Identifier Path SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;The rich have lots of money!&quot;</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token EnumID Identifier Path ID">Poor</span><span class="Token Identifier Path SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;The poor have no money...&quot;</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">    </span><span class="Token MatchExpr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">    </span><span class="Token Keyword MatchExpr MATCH">match</span><span class="Token Keyword MatchExpr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">work</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token MatchExpr BraceDepth-1 LCURLY_BRACE">{</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">        </span><span class="Token MatchExpr COMMENT">// Note again the lack of scoping.</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">        </span><span class="Token EnumID Identifier Path ID">Civilian</span><span class="Token Identifier Path SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;Civilians work!&quot;</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token EnumID Identifier Path ID">Soldier</span><span class="Token Identifier Path SPACE">  </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;Soldiers fight!&quot;</span><span class="Token MacroExpr Expr BraceDepth-2 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">    </span><span class="Token MatchExpr BraceDepth-1 RCURLY_BRACE">}</span><span class="Token MatchExpr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-16"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/16.rs" target="_blank">16.rs</a></h2><pre class="language-rust"><code><span class="Token COMMENT">// An attribute to hide warnings for unused code.</span><span class="Token LF">
</span><span class="Token InnerAttr HASH_BANG">#!</span><span class="Token InnerAttr BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier MetaItem Attribute ID">allow</span><span class="Token MetaItem InnerAttr BraceDepth-1 LPAREN">(</span><span class="Token Identifier MetaItem TraitName ID">dead_code</span><span class="Token MetaItem InnerAttr BraceDepth-1 RPAREN">)</span><span class="Token InnerAttr BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token InnerAttr LF">
</span><span class="Token InnerAttr LF">
</span><span class="Token InnerAttr COMMENT">// enum with implicit discriminator (starts at 0)</span><span class="Token InnerAttr LF">
</span><span class="Token Keyword EnumItem ENUM">enum</span><span class="Token Keyword EnumItem SPACE"> </span><span class="Token Identifier EnumItem Enumerator ID">Number</span><span class="Token Identifier EnumItem Enumerator SPACE"> </span><span class="Token EnumBody EnumItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Zero</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">One</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Two</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token EnumBody EnumItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem COMMENT">// enum with explicit discriminator</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token Keyword EnumItem ENUM">enum</span><span class="Token Keyword EnumItem SPACE"> </span><span class="Token Identifier EnumItem Enumerator ID">Color</span><span class="Token Identifier EnumItem Enumerator SPACE"> </span><span class="Token EnumBody EnumItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Red</span><span class="Token Identifier EnumMember EnumID SPACE"> </span><span class="Token EnumMember ASSIGN">=</span><span class="Token EnumMember SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0xff0000</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Green</span><span class="Token Identifier EnumMember EnumID SPACE"> </span><span class="Token EnumMember ASSIGN">=</span><span class="Token EnumMember SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0x00ff00</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Blue</span><span class="Token Identifier EnumMember EnumID SPACE"> </span><span class="Token EnumMember ASSIGN">=</span><span class="Token EnumMember SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0x0000ff</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token EnumBody EnumItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// `enums` can be cast as integers.</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;zero is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Enumerator Identifier ExprPathSegment ID">Number</span><span class="Token DOUBLE_COLON">::</span><span class="Token EnumID Identifier ExprPathSegment ID">Zero</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Keyword Expr AS">as</span><span class="Token Keyword Expr SPACE"> </span><span class="Token ImportLibName Identifier ExprPathSegment ID">i32</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;one is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Enumerator Identifier ExprPathSegment ID">Number</span><span class="Token DOUBLE_COLON">::</span><span class="Token EnumID Identifier ExprPathSegment ID">One</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Keyword Expr AS">as</span><span class="Token Keyword Expr SPACE"> </span><span class="Token ImportLibName Identifier ExprPathSegment ID">i32</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;roses are #</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">06x</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Enumerator Identifier ExprPathSegment ID">Color</span><span class="Token DOUBLE_COLON">::</span><span class="Token EnumID Identifier ExprPathSegment ID">Red</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Keyword Expr AS">as</span><span class="Token Keyword Expr SPACE"> </span><span class="Token ImportLibName Identifier ExprPathSegment ID">i32</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;violets are #</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">:</span><span class="Token String NUMBER">06x</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Enumerator Identifier ExprPathSegment ID">Color</span><span class="Token DOUBLE_COLON">::</span><span class="Token EnumID Identifier ExprPathSegment ID">Blue</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Keyword Expr AS">as</span><span class="Token Keyword Expr SPACE"> </span><span class="Token ImportLibName Identifier ExprPathSegment ID">i32</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-17"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/17.rs" target="_blank">17.rs</a></h2><pre class="language-rust"><code><span class="Token Keyword UseItem USE">use</span><span class="Token Keyword UseItem SPACE"> </span><span class="Token Keyword PathGlob CRATE">crate</span><span class="Token PathGlob UseItem DOUBLE_COLON">::</span><span class="Token Identifier ImportLibName PathGlob ID">List</span><span class="Token PathGlob PathGlob DOUBLE_COLON">::</span><span class="Token PathGlob PathGlob DEREF">*</span><span class="Token UseItem ItemWithAttrs SEMI">;</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token UseItem ItemWithAttrs LF">
</span><span class="Token Keyword EnumItem ENUM">enum</span><span class="Token Keyword EnumItem SPACE"> </span><span class="Token Identifier EnumItem Enumerator ID">List</span><span class="Token Identifier EnumItem Enumerator SPACE"> </span><span class="Token EnumBody EnumItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem SPACE">    </span><span class="Token EnumBody EnumItem COMMENT">// Cons: Tuple struct that wraps an element and a pointer to the next node</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Cons</span><span class="Token TupleStructBody BraceDepth-1 LPAREN">(</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">u32</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier TypePathSegment TypeBound ID">Box</span><span class="Token GenericValues TypePathSegment BraceDepth-2 LANGLE_BRACE">&lt;</span><span class="Token Enumerator Identifier TypePathSegment TypeBound ID">List</span><span class="Token GenericValues TypePathSegment BraceDepth-2 RANGLE_BRACE">&gt;</span><span class="Token TupleStructBody BraceDepth-1 RPAREN">)</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token COMMENT">// Nil: A node that signifies the end of the linked list</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Identifier EnumMember EnumID ID">Nil</span><span class="Token COMMA">,</span><span class="Token LF">
</span><span class="Token EnumBody EnumItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token EnumBody EnumItem COMMENT">// Methods can be attached to an enum</span><span class="Token EnumBody EnumItem LF">
</span><span class="Token Keyword ImplItem IMPL">impl</span><span class="Token Keyword ImplItem SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">List</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 LCURLY_BRACE">{</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token ImplItem ItemWithAttrs COMMENT">// Create an empty list</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token Identifier ImplMember FunctionName ID">new</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">List</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// `Nil` has type `List`</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token EnumID Identifier ExprPathSegment ID">Nil</span><span class="Token Identifier ExprPathSegment LF">
</span><span class="Token Identifier ExprPathSegment SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">    </span><span class="Token BlockExpr ImplMember COMMENT">// Consume a list, and return the same list with a new element at its front</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token Identifier ImplMember FunctionName ID">prepend</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token Keyword SelfParam SELF">self</span><span class="Token MemberFnParams ImplMember COMMA">,</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token Identifier Path ID">elem</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">u32</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">List</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// `Cons` also has type List</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token EnumID Identifier ExprPathSegment FunctionCall ID">Cons</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token Identifier ExprPathSegment ID">elem</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment ID">Box</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier ExprPathSegment FunctionCall ID">new</span><span class="Token RefGroup BraceDepth-0 LPAREN">(</span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token RefGroup BraceDepth-0 RPAREN">)</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup LF">
</span><span class="Token RefGroup SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">    </span><span class="Token BlockExpr ImplMember COMMENT">// Return the length of the list</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token Identifier ImplMember FunctionName ID">len</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam SELF">self</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">u32</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// `self` has to be matched, because the behavior of this method</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// depends on the variant of `self`</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// `self` has type `&amp;List`, and `*self` has type `List`, matching on a</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// concrete type `T` is preferred over a match on a reference `&amp;T`</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// after Rust 2018 you can use self here and tail (with no ref) below as well,</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// rust will infer &amp;s and ref tail.</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token BlockExpr ImplMember COMMENT">// See https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token Keyword MatchExpr MATCH">match</span><span class="Token Keyword MatchExpr SPACE"> </span><span class="Token UnaryGroup Expr DEREF">*</span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token Keyword PrimaryGroup SPACE"> </span><span class="Token MatchExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">            </span><span class="Token MatchExpr COMMENT">// Can&#x27;t take ownership of the tail, because `self` is borrowed;</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">            </span><span class="Token MatchExpr COMMENT">// instead take a reference to the tail</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">            </span><span class="Token EnumID Identifier Path ID">Cons</span><span class="Token Pat BraceDepth-0 LPAREN">(</span><span class="Token Identifier Path ID">_</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword Pat REF">ref</span><span class="Token Keyword Pat SPACE"> </span><span class="Token Identifier Pat ID">tail</span><span class="Token Pat BraceDepth-0 RPAREN">)</span><span class="Token Pat SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token Number PrimaryGroup SPACE"> </span><span class="Token Punctuator Expr PLUS">+</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Identifier ExprPathSegment ID">tail</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">len</span><span class="Token RefGroup BraceDepth-0 LPAREN">(</span><span class="Token RefGroup BraceDepth-0 RPAREN">)</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">            </span><span class="Token MatchItem COMMENT">// Base Case: An empty list has zero length</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">            </span><span class="Token EnumID Identifier Path ID">Nil</span><span class="Token Identifier Path SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">0</span><span class="Token Number PrimaryGroup LF">
</span><span class="Token Number PrimaryGroup SPACE">        </span><span class="Token MatchExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">    </span><span class="Token BlockExpr ImplMember COMMENT">// Return representation of the list as a (heap allocated) string</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">    </span><span class="Token Keyword ImplMember FN">fn</span><span class="Token Keyword ImplMember SPACE"> </span><span class="Token Identifier ImplMember FunctionName ID">stringify</span><span class="Token MemberFnParams ImplMember BraceDepth-1 LPAREN">(</span><span class="Token SelfParam MemberFnParams AMPERSAND">&amp;</span><span class="Token Keyword SelfParam SELF">self</span><span class="Token MemberFnParams ImplMember BraceDepth-1 RPAREN">)</span><span class="Token MemberFnParams ImplMember SPACE"> </span><span class="Token RetTy ImplMember POINT">-&gt;</span><span class="Token RetTy ImplMember SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">String</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr ImplMember BraceDepth-1 LCURLY_BRACE">{</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token BlockExpr ImplMember SPACE">        </span><span class="Token Keyword MatchExpr MATCH">match</span><span class="Token Keyword MatchExpr SPACE"> </span><span class="Token UnaryGroup Expr DEREF">*</span><span class="Token Keyword PrimaryGroup SELF">self</span><span class="Token Keyword PrimaryGroup SPACE"> </span><span class="Token MatchExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">            </span><span class="Token EnumID Identifier Path ID">Cons</span><span class="Token Pat BraceDepth-0 LPAREN">(</span><span class="Token Identifier Path ID">head</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword Pat REF">ref</span><span class="Token Keyword Pat SPACE"> </span><span class="Token Identifier Pat ID">tail</span><span class="Token Pat BraceDepth-0 RPAREN">)</span><span class="Token Pat SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token BlockExpr MatchItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr MatchItem LF">
</span><span class="Token BlockExpr MatchItem SPACE">                </span><span class="Token BlockExpr MatchItem COMMENT">// `format!` is similar to `print!`, but returns a heap</span><span class="Token BlockExpr MatchItem LF">
</span><span class="Token BlockExpr MatchItem SPACE">                </span><span class="Token BlockExpr MatchItem COMMENT">// allocated string instead of printing to the console</span><span class="Token BlockExpr MatchItem LF">
</span><span class="Token BlockExpr MatchItem SPACE">                </span><span class="Token Identifier MacroExpr MacroDefine ID">format</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">, </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">head</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">tail</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">stringify</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token MacroExpr Expr LF">
</span><span class="Token MacroExpr Expr SPACE">            </span><span class="Token BlockExpr MatchItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">            </span><span class="Token EnumID Identifier Path ID">Nil</span><span class="Token Identifier Path SPACE"> </span><span class="Token MatchItem LAMBDA_POINT">=&gt;</span><span class="Token MatchItem SPACE"> </span><span class="Token BlockExpr MatchItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr MatchItem LF">
</span><span class="Token BlockExpr MatchItem SPACE">                </span><span class="Token Identifier MacroExpr MacroDefine ID">format</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;Nil&quot;</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token MacroExpr Expr LF">
</span><span class="Token MacroExpr Expr SPACE">            </span><span class="Token BlockExpr MatchItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token MatchItem COMMA">,</span><span class="Token MatchItem LF">
</span><span class="Token MatchItem SPACE">        </span><span class="Token MatchExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token MatchExpr LF">
</span><span class="Token MatchExpr SPACE">    </span><span class="Token BlockExpr ImplMember BraceDepth-1 RCURLY_BRACE">}</span><span class="Token BlockExpr ImplMember LF">
</span><span class="Token ImplItem ItemWithAttrs BraceDepth-0 RCURLY_BRACE">}</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token ImplItem ItemWithAttrs LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// Create an empty linked list</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Keyword Pat MUT">mut</span><span class="Token Keyword Pat SPACE"> </span><span class="Token Identifier Pat MutableVar ID">list</span><span class="Token Identifier Pat SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token TypeBound Identifier ExprPathSegment ID">List</span><span class="Token DOUBLE_COLON">::</span><span class="Token Identifier ExprPathSegment FunctionCall ID">new</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// Prepend some elements</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token MutableVar Identifier ExprPathSegment ID">list</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token MutableVar Identifier ExprPathSegment ID">list</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">prepend</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">1</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token MutableVar Identifier ExprPathSegment ID">list</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token MutableVar Identifier ExprPathSegment ID">list</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">prepend</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">2</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token MutableVar Identifier ExprPathSegment ID">list</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token MutableVar Identifier ExprPathSegment ID">list</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">prepend</span><span class="Token RefGroup BraceDepth-1 LPAREN">(</span><span class="Token Number PrimaryGroup NUMBER">3</span><span class="Token RefGroup BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Show the final state of the list</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;linked list has length: </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token MutableVar Identifier ExprPathSegment ID">list</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">len</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token MutableVar Identifier ExprPathSegment ID">list</span><span class="Token RefGroup DOT">.</span><span class="Token Identifier RefGroup FunctionCall ID">stringify</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h2 id="h2-18"><a href="https://github.com/luzhixing12345/syntaxlight/tree/main/test/rust/18.rs" target="_blank">18.rs</a></h2><pre class="language-rust"><code><span class="Token COMMENT">// Globals are declared outside all other scopes.</span><span class="Token LF">
</span><span class="Token Keyword StaticItem STATIC">static</span><span class="Token Keyword StaticItem SPACE"> </span><span class="Token Identifier StaticItem ID">LANGUAGE</span><span class="Token StaticItem ItemWithAttrs COLON">:</span><span class="Token StaticItem ItemWithAttrs SPACE"> </span><span class="Token Ty StaticItem AMPERSAND">&amp;</span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">str</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token StaticItem ItemWithAttrs ASSIGN">=</span><span class="Token StaticItem ItemWithAttrs SPACE"> </span><span class="Token String STRING">&quot;Rust&quot;</span><span class="Token StaticItem ItemWithAttrs SEMI">;</span><span class="Token StaticItem ItemWithAttrs LF">
</span><span class="Token Keyword ConstItem CONST">const</span><span class="Token Keyword ConstItem SPACE"> </span><span class="Token Identifier ConstItem Constant ID">THRESHOLD</span><span class="Token ConstItem ItemWithAttrs COLON">:</span><span class="Token ConstItem ItemWithAttrs SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">i32</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token ConstItem ItemWithAttrs ASSIGN">=</span><span class="Token ConstItem ItemWithAttrs SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">10</span><span class="Token ConstItem ItemWithAttrs SEMI">;</span><span class="Token ConstItem ItemWithAttrs LF">
</span><span class="Token ConstItem ItemWithAttrs LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">is_big</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token Identifier Path ID">n</span><span class="Token FnParam COLON">:</span><span class="Token FnParam SPACE"> </span><span class="Token TypeBound Identifier TypePathSegment TypeBound ID">i32</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token RetTy FnItem POINT">-&gt;</span><span class="Token RetTy FnItem SPACE"> </span><span class="Token ImportLibName Identifier TypePathSegment TypeBound ID">bool</span><span class="Token Identifier TypePathSegment SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token BlockExpr FnItem COMMENT">// Access constant in some function</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Identifier ExprPathSegment ID">n</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr GT">&gt;</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Constant Identifier ExprPathSegment ID">THRESHOLD</span><span class="Token Identifier ExprPathSegment LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token Keyword FnItem FN">fn</span><span class="Token Keyword FnItem SPACE"> </span><span class="Token Identifier FnItem FunctionName ID">main</span><span class="Token FnParams FnItem BraceDepth-0 LPAREN">(</span><span class="Token FnParams FnItem BraceDepth-0 RPAREN">)</span><span class="Token FnParams FnItem SPACE"> </span><span class="Token BlockExpr FnItem BraceDepth-0 LCURLY_BRACE">{</span><span class="Token BlockExpr FnItem LF">
</span><span class="Token BlockExpr FnItem SPACE">    </span><span class="Token Keyword LetExpr LET">let</span><span class="Token Keyword LetExpr SPACE"> </span><span class="Token Identifier Path ID">n</span><span class="Token Identifier Path SPACE"> </span><span class="Token LetExpr ASSIGN">=</span><span class="Token LetExpr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">16</span><span class="Token LetExpr SEMI">;</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token LetExpr COMMENT">// Access constant in the main thread</span><span class="Token LetExpr LF">
</span><span class="Token LetExpr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;This is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">LANGUAGE</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;The threshold is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Constant Identifier ExprPathSegment ID">THRESHOLD</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Identifier MacroExpr MacroDefine ID">println</span><span class="Token MacroExpr Expr BANG">!</span><span class="Token MacroExpr Expr BraceDepth-1 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING"> is </span><span class="Token Format String STRING">{</span><span class="Token Format String STRING">}</span><span class="Token String STRING">&quot;</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier ExprPathSegment ID">n</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword IfExpr IF">if</span><span class="Token Keyword IfExpr SPACE"> </span><span class="Token Identifier ExprPathSegment FunctionCall ID">is_big</span><span class="Token RefGroup BraceDepth-2 LPAREN">(</span><span class="Token Identifier ExprPathSegment ID">n</span><span class="Token RefGroup BraceDepth-2 RPAREN">)</span><span class="Token RefGroup SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token BlockExpr IfExpr SPACE"> </span><span class="Token String STRING">&quot;big&quot;</span><span class="Token SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token BlockExpr IfExpr SPACE"> </span><span class="Token IfExpr PrimaryGroup ELSE">else</span><span class="Token IfExpr PrimaryGroup SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 LCURLY_BRACE">{</span><span class="Token BlockExpr IfExpr SPACE"> </span><span class="Token String STRING">&quot;small&quot;</span><span class="Token SPACE"> </span><span class="Token BlockExpr IfExpr BraceDepth-2 RCURLY_BRACE">}</span><span class="Token MacroExpr Expr BraceDepth-1 RPAREN">)</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// Error! Cannot modify a `const`.</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Constant Identifier ExprPathSegment ID">THRESHOLD</span><span class="Token Identifier ExprPathSegment SPACE"> </span><span class="Token Punctuator Expr ASSIGN">=</span><span class="Token Punctuator Expr SPACE"> </span><span class="Token Number PrimaryGroup NUMBER">5</span><span class="Token Expr SEMI">;</span><span class="Token Expr LF">
</span><span class="Token Expr SPACE">    </span><span class="Token Expr COMMENT">// FIXME ^ Comment out this line</span><span class="Token Expr LF">
</span><span class="Token BlockExpr FnItem BraceDepth-0 RCURLY_BRACE">}</span></code></pre></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../用户手册/API" >用户手册</a><ul><li><a href="../../用户手册/API" >API</a></li></ul><ul><li><a href="../../用户手册/全部文法支持" >全部文法支持</a></li></ul><ul><li><a href="../../用户手册/自定义颜色" >自定义颜色</a></li></ul><ul><li><a href="../../用户手册/自定义文法解析" >自定义文法解析</a></li></ul><ul><li><a href="../../用户手册/文法扩展" >文法扩展</a></li></ul><ul><li><a href="../../用户手册/已知问题" >已知问题</a></li></ul></li></ul><ul><li><a href="../../全部文法高亮/C" >全部文法高亮</a><ul><li><a href="../../全部文法高亮/C" >C</a></li></ul><ul><li><a href="../../全部文法高亮/Lua" >Lua</a></li></ul><ul><li><a href="../../全部文法高亮/x86asm" >x86asm</a></li></ul><ul><li><a href="../../全部文法高亮/riscvasm" >riscvasm</a></li></ul><ul><li><a href="../../全部文法高亮/BNF" >BNF</a></li></ul><ul><li><a href="../../全部文法高亮/json" >json</a></li></ul><ul><li><a href="../../全部文法高亮/shell" >shell</a></li></ul><ul><li><a href="../../全部文法高亮/toml" >toml</a></li></ul><ul><li><a href="../../全部文法高亮/xml" >xml</a></li></ul><ul><li><a href="../../全部文法高亮/css" >css</a></li></ul><ul><li><a href="../../全部文法高亮/dot" >dot</a></li></ul><ul><li><a href="../../全部文法高亮/yaml" >yaml</a></li></ul><ul><li><a href="../../全部文法高亮/txt" >txt</a></li></ul><ul><li><a href="../../全部文法高亮/verilog" >verilog</a></li></ul><ul><li><a href="../../全部文法高亮/rust" >rust</a></li></ul></li></ul><ul><li><a href="../../开发文档/BNF" >开发文档</a><ul><li><a href="../../开发文档/BNF" >BNF</a></li></ul><ul><li><a href="../../开发文档/参考文档" >参考文档</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../全部文法高亮/verilog","../../开发文档/BNF","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>